# 35. 🔐 500 에러 대응 Part1 – 서버 오류를 막는 법

---

## 📦 500 에러란?

### 💡 **500 에러**는 서버에서 **예기치 않은 오류**가 발생했을 때 발생하는 **서버 오류**입니다.  
서버가 요청을 처리할 수 없을 때 **500 에러**를 반환합니다. 이는 **서버 내부의 문제**로 인해 요청이 실패했음을 의미합니다. **500 에러**는 **서버에서 예기치 않게 발생한 오류**에 대해 **우리가 어떻게 대처할지**가 중요한 부분입니다.

- **서버 내부에서 발생한 오류**는 **사용자에게 노출되지 않도록** 적절히 처리하고, **친절한 메시지**를 보여주어야 합니다.

---

## 🧠 500 에러 처리 이유

- **사용자 경험 향상**: 사용자가 **서버 오류**를 직접적으로 보고 불안해하지 않도록, 적절히 에러를 처리하고 안내 메시지를 제공하는 것이 중요합니다.
- **에러 로그 관리**: 서버에서 발생한 **500 에러**를 **로그로 기록**하여 개발자가 문제를 추적할 수 있도록 해야 합니다.
- **보안성 강화**: **서버의 내부 구조**나 **디버그 정보**가 **사용자에게 노출되지 않도록** 하여 보안을 유지해야 합니다.

---

## 🔍 500 에러 처리 – 코드 설명

### **500 에러 처리 예제 (errorHandling500.js)**

```js
// path 모듈을 불러옵니다. (디렉토리 경로를 쉽게 관리하기 위해 사용)
const path = require("path");
// express 모듈을 불러옵니다. (웹 서버를 구축하기 위한 라이브러리)
const express = require("express");
// Express 애플리케이션 인스턴스를 생성합니다.
const app = express();

// 뷰 엔진을 EJS로 설정합니다. EJS는 서버에서 동적으로 HTML을 생성할 수 있는 템플릿 엔진입니다.
app.set("view engine", "ejs");
// 'views' 폴더를 템플릿 파일을 찾을 디렉토리로 설정합니다. __dirname은 현재 파일의 디렉토리 경로를 참조합니다.
app.set("views", path.join(__dirname, "views"));

// 1. 동기 코드에서 직접 오류를 발생시키는 경우
// 이 라우트에서는 요청을 받으면 동기적으로 오류를 발생시킵니다.
app.get("/", (req, res) => {
  // 오류를 발생시킵니다. 이 오류는 바로 아래 미들웨어로 넘어가게 됩니다.
  throw new Error("Something went wrong!"); 
});

// 2. next 함수를 사용하여 오류를 명시적으로 전달하는 경우
// 'next()'를 사용하여 오류를 명시적으로 전달합니다.
app.get("/", (req, res, next) => {
  // 오류 객체를 생성합니다.
  const err = new Error("Something went wrong!");
  // next()를 통해 이 오류를 Express의 오류 처리 미들웨어로 전달합니다.
  next(err);
});

// 3. 비동기 작업에서 발생한 오류를 next 함수로 전달하는 경우
// 비동기 작업에서 오류가 발생한 경우, 그 오류를 처리하기 위해 next()를 사용합니다.
app.get("/", (req, res, next) => {
  setTimeout(() => {
    try {
      // 비동기 코드 내에서 오류를 발생시킵니다.
      throw new Error("Async error");
    } catch (err) {
      // 오류가 발생하면, 이를 next()로 전달하여 오류 처리 미들웨어로 넘깁니다.
      next(err);
    }
  }, 1000); // setTimeout은 비동기 작업의 예시입니다.
});

// 4. Promise 또는 async/await 구문에서 발생한 오류를 처리하지 않고 next로 전달하는 경우
// async/await를 사용하는 비동기 작업에서 오류가 발생하면, 이를 처리하지 않고 next()로 전달합니다.
app.get("/", async (req, res, next) => {
  try {
    // someAsyncOperation()은 비동기 함수로 예시입니다.
    await someAsyncOperation(); 
  } catch (err) {
    // 오류 발생 시 next()로 오류를 전달합니다.
    next(err);
  }
});

// 5. 기타 미들웨어에서 next를 호출하여 다음 오류 처리 미들웨어로 직접 이동하는 경우
// 특정 조건에 따라 오류를 처리하거나 다음 미들웨어로 넘어갑니다.
app.use((req, res, next) => {
  // someCondition은 조건을 확인하는 예시입니다. 
  if (someCondition) {
    // 조건이 맞으면 다음 미들웨어로 넘어갑니다.
    next(); 
  } else {
    // 조건이 맞지 않으면 오류를 발생시킵니다.
    const error = new Error("Error message");
    // 오류가 발생하면 이를 next()로 오류 처리 미들웨어로 전달합니다.
    next(error);
  }
});

// 404 페이지 처리 미들웨어 (잘못된 경로 접근 시)
// 사용자가 존재하지 않는 경로를 요청할 때 404 페이지를 렌더링합니다.
app.use((req, res, next) => {
  // 404 상태 코드와 함께 404.ejs 템플릿을 렌더링합니다.
  res.status(404).render("404", { url: req.url });
});

// 500 에러 처리 미들웨어
// 위에서 발생한 모든 오류는 이 미들웨어로 전달됩니다.
app.use((err, req, res, next) => {
  // 오류 스택을 콘솔에 출력하여 서버 로그를 기록합니다. 
  // 이렇게 하면 개발자는 오류의 원인을 추적할 수 있습니다.
  console.error(err.stack); 
  // 사용자에게는 500 에러 메시지와 함께 응답을 보냅니다.
  res.status(500).send("Internal Server Error"); 
});

// 서버 실행
// 포트 3000에서 애플리케이션을 실행합니다.
app.listen(3000, () => {
  console.log("Listening on port 3000"); 
});
```

#### **설명**:
1. **뷰 엔진 설정**:
   - `app.set("view engine", "ejs")`를 통해 **EJS 템플릿 엔진**을 설정하여 동적 HTML을 생성할 수 있게 만듭니다.
   - `app.set("views", path.join(__dirname, "views"))`는 템플릿 파일들이 있는 **views** 디렉토리의 경로를 설정합니다.

2. **오류 발생 (동기 코드)**:
   - `throw new Error("Something went wrong!")`를 사용하여 오류를 직접 발생시킵니다. 이는 **동기 코드**에서 발생한 오류로, 즉시 처리되지 않으면 **Express의 오류 처리 미들웨어로 전달**됩니다.

3. **next 함수로 오류 전달**:
   - `next(err)`를 사용하여 **명시적으로** 오류를 다음 미들웨어로 전달합니다. 이를 통해 발생한 오류가 **500 에러 처리 미들웨어**로 이동합니다.

4. **비동기 오류 처리**:
   - `setTimeout`을 사용한 비동기 작업에서 오류가 발생했을 때, `next(err)`로 해당 오류를 **전달**하여 **500 에러 처리 미들웨어**로 넘어가도록 합니다.

5. **Promise 또는 async/await에서 오류 처리**:
   - **async/await** 구문에서 발생한 오류도 `next(err)`를 통해 미들웨어로 전달됩니다. **Promise** 구문에서도 비슷한 방식으로 오류를 처리합니다.

6. **미들웨어에서 조건에 따라 오류 처리**:
   - **조건에 맞지 않으면** 오류를 생성하고 `next(error)`를 사용하여 오류를 **다음 미들웨어**로 전달하는 예시입니다.

7. **404 페이지 처리**:
   - 사용자가 **존재하지 않는 경로**로 요청하면 **404 에러 페이지**를 렌더링하여 안내 메시지를 보여줍니다.

8. **500 에러 처리 미들웨어**:
   - 오류가 발생하면 **500 상태 코드**와 함께 **"Internal Server Error"** 메시지를 사용자에게 보냅니다.
   - 또한 **에러 로그**를 출력하여 개발자가 문제를 추적할 수 있도록 돕습니다.

---

## 📊 500 에러 처리 흐름 요약 시각화

```js
🧍 사용자: /some-page 요청 → 서버에서 오류 발생
──────────────────────────────────────
↓
📦 서버:
  - 오류 발생 → next()로 에러 전달
  - 오류 처리 미들웨어로 이동

🧍 사용자: 500 에러 메시지 응답
──────────────────────────────────────
↓
📦 서버:
  - 500 에러 상태 코드와 함께 "Internal Server Error" 메시지 응답
```

---

## 🧪 실제 요청 확인 (브라우저 개발자 도구)

```http
GET /some-page HTTP/1.1
Host: localhost:3000
```

> 만약 **서버에서 오류**가 발생하면, **500 에러**가 발생하고, 사용자에게 **500 Internal Server Error** 메시지를 응답합니다.

---

## 🔐 보안 팁 – 500 에러 처리 시 안전하게 구현하기

| 설정 | 설명 | 추천 여부 |
|------|------|-----------|
| **에러 로그 기록** | **서버의 에러**를 **콘솔에 기록**하여, 개발자가 오류를 추적할 수 있도록 합니다. | ✅ 필수 |
| **디버그 정보 숨기기** | **500 에러 페이지**에 **서버의 내부 디버그 정보**가 노출되지 않도록 주의해야 합니다. | ✅ 필수 |
| **사용자에게 친절한 메시지 제공** | **500 에러**가 발생하더라도, **사용자에게 친절한 메시지**를 제공하여 불안감을 덜어줍니다. | ✅ 필수 |
| **`next(err)` 사용** | 비동기 코드에서 오류가 발생하면 **`next(err)`**를 사용하여 오류를 미들웨어로 전달합니다. | ✅ 필수 |

---

## ✅ Express에서 500 에러 처리 메서드 정리

| 메서드 | 설명 | 예시 |
|--------|------|------|
| **`next(err)`** | 오류를 **다음 미들웨어로 전달**하는 함수입니다. | `next(new Error("Something went wrong!"))` |
| **`res.status(500).send()`** | **500 에러 상태 코드**와 함께 **에러 메시지**를 사용자에게 전달합니다. | `res.status(500).send("Internal Server Error")` |

---

## 🔚 마무리 요약

| 개념 | 설명 |
|------|------|
| 500 에러 페이지 | **서버 오류** 발생 시, **친절한 에러 메시지**를 사용자에게 제공하고, **서버 로그**에 오류를 기록합니다. |
| Express 구현 | **동기/비동기 코드**에서 발생한 오류를 **`next(err)`**를 통해 **에러 처리 미들웨어**로 전달합니다. |
| 보안 관리 | **디버그 정보**를 사용자에게 **노출하지 않도록** 하여 보안을 강화하고, 친절한 오류 메시지로 사용자 경험을 향상시킵니다. |
